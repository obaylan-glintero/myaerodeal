import { create } from 'zustand';
import * as pdfjsLib from 'pdfjs-dist/legacy/build/pdf';
import pdfjsWorker from 'pdfjs-dist/legacy/build/pdf.worker.min.mjs?url';
import { supabase, isSupabaseConfigured } from '../lib/supabase';

// Configure PDF.js worker - use local bundled worker
pdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorker;

// Demo data for fallback
const DEMO_DATA = {
  leads: [
    {
      id: 1,
      name: 'John Smith',
      company: 'Tech Corp',
      aircraftType: 'Midsize Jet',
      budget: 8000000,
      budgetKnown: true,
      yearPreference: { oldest: 2015, newest: 2023 },
      status: 'Hot',
      presentations: [],
      timestampedNotes: [],
      createdAt: '2025-01-15',
      notes: 'Looking for immediate purchase'
    },
    {
      id: 2,
      name: 'Sarah Johnson',
      company: 'Global Ventures',
      aircraftType: 'Heavy Jet',
      budget: null,
      budgetKnown: false,
      yearPreference: { oldest: 2018, newest: 2025 },
      status: 'Warm',
      presentations: [],
      timestampedNotes: [],
      createdAt: '2025-02-10',
      notes: 'Flexible on specifications'
    }
  ],

  aircraft: [
    {
      id: 1,
      manufacturer: 'Gulfstream',
      model: 'G650ER',
      yom: 2020,
      serialNumber: 'SN-6350',
      registration: 'N650GS',
      category: 'Heavy Jet',
      location: 'Van Nuys, CA',
      price: 65000000,
      specSheet: null,
      presentations: [],
      timestampedNotes: [],
      accessType: 'Direct',
      createdAt: '2025-01-20',
      imageUrl: null,
      imageData: null
    },
    {
      id: 2,
      manufacturer: 'Bombardier',
      model: 'Global 7500',
      yom: 2022,
      serialNumber: 'SN-75100',
      registration: 'N7500BD',
      category: 'Heavy Jet',
      location: 'Teterboro, NJ',
      price: 73000000,
      specSheet: null,
      presentations: [],
      timestampedNotes: [],
      accessType: 'Broker',
      createdAt: '2025-01-25',
      imageUrl: null,
      imageData: null
    }
  ],

  deals: [
    {
      id: 1,
      dealName: 'Smith G650ER Acquisition',
      clientName: 'John Smith',
      relatedLead: 1,
      relatedAircraft: 1,
      dealValue: 65000000,
      estimatedClosing: '2025-04-15',
      status: 'APA Signed',
      nextStep: 'Schedule pre-purchase inspection',
      followUpDate: '2025-03-20',
      createdAt: '2025-03-01',
      history: [],
      timestampedNotes: [],
      document: null,
      documentData: null,
      documentType: null
    }
  ],

  tasks: [
    {
      id: 1,
      title: 'Schedule pre-purchase inspection',
      description: 'Coordinate with maintenance facility for G650ER inspection',
      dueDate: '2025-03-20',
      relatedTo: { type: 'deal', id: 1 },
      status: 'pending',
      priority: 'high',
      createdAt: '2025-03-01',
      autoGenerated: true
    },
    {
      id: 2,
      title: 'Follow up with Sarah Johnson',
      description: 'Discuss Global 7500 presentation feedback',
      dueDate: '2025-03-15',
      relatedTo: { type: 'lead', id: 2 },
      status: 'pending',
      priority: 'medium',
      createdAt: '2025-03-10',
      autoGenerated: false
    }
  ]
};

export const useStore = create((set, get) => ({
  // State
  leads: [],
  aircraft: [],
  deals: [],
  tasks: [],
  loading: true,
  error: null,
  isAuthenticated: false,
  currentUser: null,
  companyUsers: [],
  currentUserProfile: null,
  aircraftFullDataLoaded: new Set(), // Track which aircraft have full data loaded
  aircraftLoading: new Set(), // Track which aircraft are currently loading
  leadsFullDataLoaded: new Set(), // Track which leads have full data loaded
  leadsLoading: new Set(), // Track which leads are currently loading
  dealsFullDataLoaded: new Set(), // Track which deals have full data loaded
  dealsLoading: new Set(), // Track which deals are currently loading

  // Initialize store - fetch from Supabase or use demo data
  initialize: async () => {
    set({ loading: true, error: null });

    try {
      // Clear localStorage demo data
      console.log('ðŸ§¹ Clearing localStorage demo data...');
      localStorage.removeItem('jetcrm-data');

      // Check if Supabase is configured
      console.log('ðŸ” Checking Supabase configuration...');
      const configured = isSupabaseConfigured();
      console.log('Supabase configured:', configured);

      if (!configured) {
        console.log('âš ï¸ Supabase not configured - empty data');
        console.log('Add VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY to .env file to enable database');
        set({
          leads: [],
          aircraft: [],
          deals: [],
          tasks: [],
          loading: false,
          isAuthenticated: false
        });
        return;
      }

      // Check authentication
      const { data: { user }, error: authError } = await supabase.auth.getUser();

      if (authError || !user) {
        console.log('User not authenticated - empty data');
        set({
          leads: [],
          aircraft: [],
          deals: [],
          tasks: [],
          loading: false,
          isAuthenticated: false,
          currentUser: null
        });
        return;
      }

      console.log('User authenticated - loading profile first');
      set({ isAuthenticated: true, currentUser: user });

      // Load user profile FIRST (required for RLS to work)
      console.log('Fetching profile for user:', user.id);
      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('*')
        .eq('id', user.id)
        .single();

      if (profileError) {
        console.error('âŒ Error fetching profile:', profileError);
      }

      if (!profile) {
        console.error('âŒ No profile found for user:', user.id);
        console.error('Run this in Supabase SQL Editor:');
        console.error(`
          -- Check if profile exists
          SELECT * FROM public.profiles WHERE id = '${user.id}';

          -- If no profile, create one:
          INSERT INTO public.profiles (id, company_id, role, first_name, last_name)
          VALUES (
            '${user.id}',
            (SELECT id FROM public.companies LIMIT 1),
            'admin',
            'Admin',
            'User'
          );
        `);
        set({
          leads: [],
          aircraft: [],
          deals: [],
          tasks: [],
          loading: false
        });
        return;
      }

      console.log('âœ… Profile loaded:', profile);

      // Load company info separately
      const { data: company } = await supabase
        .from('companies')
        .select('*')
        .eq('id', profile.company_id)
        .single();

      console.log('âœ… Company loaded:', company);
      set({ currentUserProfile: { ...profile, company } });

      // Now fetch all data from Supabase (RLS automatically filters by company_id)
      console.log('Fetching data from Supabase...');

      // Only fetch minimal fields for faster initial load
      const leadsMinimalFields = 'id, name, company, aircraft_type, budget, budget_known, year_preference, status, presentations, timestamped_notes, created_at';
      const aircraftMinimalFields = 'id, manufacturer, model, yom, category, location, price, status, seller, image_url, access_type, spec_sheet, summary, presentations, serial_number, registration, created_at';
      const dealsMinimalFields = 'id, deal_name, client_name, related_lead, related_aircraft, deal_value, estimated_closing, status, next_step, follow_up_date, created_at';

      const [leadsResult, aircraftResult, dealsResult, tasksResult] = await Promise.all([
        supabase.from('leads').select(leadsMinimalFields).order('created_at', { ascending: false }),
        supabase.from('aircraft').select(aircraftMinimalFields).order('created_at', { ascending: false }),
        supabase.from('deals').select(dealsMinimalFields).order('created_at', { ascending: false }),
        supabase.from('tasks').select('*').order('created_at', { ascending: false })
      ]);

      // Enhanced debugging
      console.log('=== SUPABASE DATA FETCH DEBUG ===');
      console.log('User ID:', user.id);
      console.log('User Email:', user.email);

      // Handle errors with detailed logging
      if (leadsResult.error) {
        console.error('âŒ Error fetching leads:', leadsResult.error);
      } else {
        console.log('âœ… Leads fetched:', leadsResult.data?.length || 0, 'records');
      }

      if (aircraftResult.error) {
        console.error('âŒ Error fetching aircraft:', aircraftResult.error);
      } else {
        console.log('âœ… Aircraft fetched:', aircraftResult.data?.length || 0, 'records');
      }

      if (dealsResult.error) {
        console.error('âŒ Error fetching deals:', dealsResult.error);
      } else {
        console.log('âœ… Deals fetched:', dealsResult.data?.length || 0, 'records');
      }

      if (tasksResult.error) {
        console.error('âŒ Error fetching tasks:', tasksResult.error);
      } else {
        console.log('âœ… Tasks fetched:', tasksResult.data?.length || 0, 'records');
      }

      console.log('=================================');

      // Convert database format to app format
      // Minimal converter for leads - only essential fields for list/card view
      const convertLeadMinimalFromDB = (lead) => {
        const converted = {
          id: lead.id,
          name: lead.name || '',
          company: lead.company || '',
          aircraftType: lead.aircraft_type || '',
          budget: lead.budget,
          budgetKnown: lead.budget_known || false,
          yearPreference: lead.year_preference || { oldest: null, newest: null },
          status: lead.status || 'Inquiry',
          presentations: lead.presentations || [],
          timestampedNotes: lead.timestamped_notes || [],
          createdAt: lead.created_at?.split('T')[0] || new Date().toISOString().split('T')[0],
          // Placeholder for full data (will be loaded on demand)
          notes: ''
        };
        console.log('ðŸ”„ Converting lead (minimal) from DB:', lead.name, 'status:', lead.status, 'â†’', converted.status);
        return converted;
      };

      // Full converter for leads - all fields including heavy data
      const convertLeadFullFromDB = (lead) => {
        const converted = {
          id: lead.id,
          name: lead.name || '',
          company: lead.company || '',
          aircraftType: lead.aircraft_type || '',
          budget: lead.budget,
          budgetKnown: lead.budget_known || false,
          yearPreference: lead.year_preference || { oldest: null, newest: null },
          status: lead.status || 'Inquiry',
          notes: lead.notes || '',
          presentations: lead.presentations || [],
          timestampedNotes: lead.timestamped_notes || [],
          createdAt: lead.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
        };
        console.log('ðŸ”„ Converting lead (full) from DB:', lead.name, 'status:', lead.status, 'â†’', converted.status);
        return converted;
      };

      // Minimal converter - only essential fields for list/card view
      const convertAircraftMinimalFromDB = (aircraft) => ({
        id: aircraft.id,
        manufacturer: aircraft.manufacturer || '',
        model: aircraft.model || '',
        yom: aircraft.yom,
        category: aircraft.category || '',
        location: aircraft.location || '',
        price: aircraft.price || 0,
        status: aircraft.status || 'For Sale',
        seller: aircraft.seller || '',
        imageUrl: aircraft.image_url,
        imageData: null, // Will be loaded on demand
        accessType: aircraft.access_type || 'Direct',
        specSheet: aircraft.spec_sheet, // Include filename so UI knows if spec sheet exists
        summary: aircraft.summary || '', // AI-generated summary for display
        presentations: aircraft.presentations || [], // Which leads this was presented to
        serialNumber: aircraft.serial_number || '', // Include for summary card display
        registration: aircraft.registration || '', // Include for summary card display
        createdAt: aircraft.created_at?.split('T')[0] || new Date().toISOString().split('T')[0],
        // Placeholders for full data (will be loaded on demand)
        specSheetData: null,
        specSheetType: null,
        timestampedNotes: []
      });

      // Full converter - all fields including heavy data
      const convertAircraftFullFromDB = (aircraft) => ({
        id: aircraft.id,
        manufacturer: aircraft.manufacturer || '',
        model: aircraft.model || '',
        yom: aircraft.yom,
        serialNumber: aircraft.serial_number || '',
        registration: aircraft.registration || '',
        category: aircraft.category || '',
        location: aircraft.location || '',
        price: aircraft.price || 0,
        accessType: aircraft.access_type || 'Direct',
        summary: aircraft.summary || '',
        status: aircraft.status || 'For Sale',
        seller: aircraft.seller || '',
        specSheet: aircraft.spec_sheet,
        specSheetData: aircraft.spec_sheet_data,
        specSheetType: aircraft.spec_sheet_type,
        imageUrl: aircraft.image_url,
        imageData: aircraft.image_data,
        presentations: aircraft.presentations || [],
        timestampedNotes: aircraft.timestamped_notes || [],
        createdAt: aircraft.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
      });

      // Minimal converter for deals - only essential fields for list/card view
      const convertDealMinimalFromDB = (deal) => {
        console.log('ðŸ”„ Converting deal (minimal) from DB:', deal.id, deal.deal_name);
        return {
          id: deal.id,
          dealName: deal.deal_name || '',
          clientName: deal.client_name || '',
          relatedLead: deal.related_lead,
          relatedAircraft: deal.related_aircraft,
          dealValue: deal.deal_value || 0,
          estimatedClosing: deal.estimated_closing || '',
          status: deal.status || 'LOI Signed',
          nextStep: deal.next_step || '',
          followUpDate: deal.follow_up_date || '',
          createdAt: deal.created_at?.split('T')[0] || new Date().toISOString().split('T')[0],
          // Placeholders for full data (will be loaded on demand)
          document: null,
          documentData: null,
          documentType: null,
          history: [],
          timestampedNotes: [],
          timeline: null,
          timelineGenerated: null,
          documentParsed: null
        };
      };

      // Full converter for deals - all fields including heavy data
      const convertDealFullFromDB = (deal) => {
        console.log('ðŸ”„ Converting deal (full) from DB:', deal.id, deal.deal_name);
        console.log('  - document:', deal.document);
        console.log('  - document_data exists:', !!deal.document_data, deal.document_data ? `(${deal.document_data.length} chars)` : '');
        console.log('  - document_type:', deal.document_type);
        return {
          id: deal.id,
          dealName: deal.deal_name || '',
          clientName: deal.client_name || '',
          relatedLead: deal.related_lead,
          relatedAircraft: deal.related_aircraft,
          dealValue: deal.deal_value || 0,
          estimatedClosing: deal.estimated_closing || '',
          status: deal.status || 'LOI Signed',
          nextStep: deal.next_step || '',
          followUpDate: deal.follow_up_date || '',
          document: deal.document,
          documentData: deal.document_data,
          documentType: deal.document_type,
          history: deal.history || [],
          timestampedNotes: deal.timestamped_notes || [],
          timeline: deal.timeline,
          timelineGenerated: deal.timeline_generated,
          documentParsed: deal.document_parsed,
          createdAt: deal.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
        };
      };

      const convertTaskFromDB = (task) => ({
        id: task.id,
        title: task.title || '',
        description: task.description || '',
        dueDate: task.due_date || '',
        relatedTo: task.related_to || null,
        status: task.status || 'pending',
        priority: task.priority || 'medium',
        autoGenerated: task.auto_generated || false,
        createdAt: task.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
      });

      // Check if this is a new company with no data AND sample data hasn't been created yet
      const hasNoData =
        (!leadsResult.data || leadsResult.data.length === 0) &&
        (!aircraftResult.data || aircraftResult.data.length === 0) &&
        (!dealsResult.data || dealsResult.data.length === 0) &&
        (!tasksResult.data || tasksResult.data.length === 0);

      // Only create sample data if:
      // 1. Company has no data
      // 2. Sample data hasn't been created before (sample_data_created is false or null)
      const shouldCreateSampleData = hasNoData && !company?.sample_data_created;

      if (hasNoData && company?.sample_data_created) {
        console.log('â„¹ï¸ Company has no data, but sample data was already created once. Not recreating.');
      }

      if (shouldCreateSampleData) {
        console.log('ðŸŒ± New company detected - creating sample data for the first time...');

        // Create sample data for the new company
        try {
          await get().createSampleDataForNewCompany(user.id, profile.company_id);

          // Mark sample data as created so it doesn't happen again
          await supabase
            .from('companies')
            .update({ sample_data_created: true })
            .eq('id', profile.company_id);

          // Re-fetch data after creating samples
          console.log('ðŸ“Š Re-fetching data after sample creation...');
          const [newLeadsResult, newAircraftResult, newDealsResult, newTasksResult] = await Promise.all([
            supabase.from('leads').select(leadsMinimalFields).order('created_at', { ascending: false }),
            supabase.from('aircraft').select(aircraftMinimalFields).order('created_at', { ascending: false }),
            supabase.from('deals').select(dealsMinimalFields).order('created_at', { ascending: false }),
            supabase.from('tasks').select('*').order('created_at', { ascending: false })
          ]);

          set({
            leads: newLeadsResult.data?.map(convertLeadMinimalFromDB) || [],
            aircraft: newAircraftResult.data?.map(convertAircraftMinimalFromDB) || [],
            deals: newDealsResult.data?.map(convertDealMinimalFromDB) || [],
            tasks: newTasksResult.data?.map(convertTaskFromDB) || [],
            loading: false,
            aircraftFullDataLoaded: new Set(), // Reset tracking
            leadsFullDataLoaded: new Set(),
            dealsFullDataLoaded: new Set()
          });

          console.log('âœ… Sample data created and loaded! This will only happen once.');
        } catch (sampleError) {
          console.error('âŒ Error creating sample data:', sampleError);
          // Continue with empty data if sample creation fails
          set({
            leads: [],
            aircraft: [],
            deals: [],
            tasks: [],
            loading: false
          });
        }
      } else {
        // Company has existing data
        set({
          leads: leadsResult.data?.map(convertLeadMinimalFromDB) || [],
          aircraft: aircraftResult.data?.map(convertAircraftMinimalFromDB) || [],
          deals: dealsResult.data?.map(convertDealMinimalFromDB) || [],
          tasks: tasksResult.data?.map(convertTaskFromDB) || [],
          loading: false,
          aircraftFullDataLoaded: new Set(), // Reset tracking
          leadsFullDataLoaded: new Set(),
          dealsFullDataLoaded: new Set()
        });
      }

      // Set up real-time subscriptions
      get().setupRealtimeSubscriptions(user.id);

    } catch (error) {
      console.error('Error initializing store:', error);
      set({
        error: error.message,
        loading: false,
        ...DEMO_DATA
      });
    }
  },

  // Set up real-time subscriptions for data changes
  setupRealtimeSubscriptions: (userId) => {
    // Subscribe to leads changes (RLS handles company filtering)
    supabase
      .channel('leads_changes')
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'leads' },
        (payload) => {
          console.log('ðŸ“¡ Realtime lead change:', payload.eventType, payload);
          const { leads } = get();

          if (payload.eventType === 'INSERT' && payload.new) {
            const newLead = {
              id: payload.new.id,
              name: payload.new.name || '',
              company: payload.new.company || '',
              aircraftType: payload.new.aircraft_type || '',
              budget: payload.new.budget,
              budgetKnown: payload.new.budget_known || false,
              yearPreference: payload.new.year_preference || { oldest: null, newest: null },
              status: payload.new.status || 'Inquiry',
              notes: payload.new.notes || '',
              presentations: payload.new.presentations || [],
              timestampedNotes: payload.new.timestamped_notes || [],
              createdAt: payload.new.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
            };
            console.log('âž• Adding new lead from realtime:', newLead);
            set({ leads: [...leads, newLead] });
          } else if (payload.eventType === 'UPDATE' && payload.new) {
            const updatedLead = {
              id: payload.new.id,
              name: payload.new.name || '',
              company: payload.new.company || '',
              aircraftType: payload.new.aircraft_type || '',
              budget: payload.new.budget,
              budgetKnown: payload.new.budget_known || false,
              yearPreference: payload.new.year_preference || { oldest: null, newest: null },
              status: payload.new.status || 'Inquiry',
              notes: payload.new.notes || '',
              presentations: payload.new.presentations || [],
              timestampedNotes: payload.new.timestamped_notes || [],
              createdAt: payload.new.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
            };
            console.log('ðŸ”„ Updating lead from realtime:', updatedLead);
            set({ leads: leads.map(lead => lead.id === updatedLead.id ? updatedLead : lead) });
          } else if (payload.eventType === 'DELETE' && payload.old) {
            console.log('ðŸ—‘ï¸ Deleting lead from realtime:', payload.old.id);
            set({ leads: leads.filter(lead => lead.id !== payload.old.id) });
          }
        }
      )
      .subscribe();

    // Subscribe to aircraft changes (RLS handles company filtering)
    supabase
      .channel('aircraft_changes')
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'aircraft' },
        () => {
          get().refreshAircraft();
        }
      )
      .subscribe();

    // Subscribe to deals changes (RLS handles company filtering)
    supabase
      .channel('deals_changes')
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'deals' },
        () => {
          get().refreshDeals();
        }
      )
      .subscribe();

    // Subscribe to tasks changes (RLS handles company filtering)
    supabase
      .channel('tasks_changes')
      .on('postgres_changes',
        { event: '*', schema: 'public', table: 'tasks' },
        () => {
          get().refreshTasks();
        }
      )
      .subscribe();
  },

  // Create sample data for new companies (only runs once per company)
  createSampleDataForNewCompany: async (userId, companyId) => {
    console.log('ðŸŒ± Creating sample data for company:', companyId);

    try {
      // Insert sample leads
      console.log('ðŸ“ Inserting sample leads...');
      const leadsToInsert = DEMO_DATA.leads.map(lead => ({
        user_id: userId,
        company_id: companyId,
        name: lead.name,
        company: lead.company,
        aircraft_type: lead.aircraftType,
        budget: lead.budget,
        budget_known: lead.budgetKnown,
        year_preference: lead.yearPreference,
        status: lead.status,
        notes: lead.notes,
        presentations: [],
        timestamped_notes: []
      }));

      const { data: insertedLeads, error: leadsError } = await supabase
        .from('leads')
        .insert(leadsToInsert)
        .select();

      if (leadsError) {
        console.error('âŒ Error inserting sample leads:', leadsError);
        throw leadsError;
      }

      console.log('âœ… Inserted', insertedLeads?.length || 0, 'sample leads');

      // Insert sample aircraft
      console.log('âœˆï¸ Inserting sample aircraft...');
      const aircraftToInsert = DEMO_DATA.aircraft.map(aircraft => ({
        user_id: userId,
        company_id: companyId,
        manufacturer: aircraft.manufacturer,
        model: aircraft.model,
        yom: aircraft.yom,
        serial_number: aircraft.serialNumber,
        registration: aircraft.registration,
        category: aircraft.category,
        location: aircraft.location,
        price: aircraft.price,
        access_type: aircraft.accessType,
        presentations: [],
        timestamped_notes: []
      }));

      const { data: insertedAircraft, error: aircraftError } = await supabase
        .from('aircraft')
        .insert(aircraftToInsert)
        .select();

      if (aircraftError) {
        console.error('âŒ Error inserting sample aircraft:', aircraftError);
        throw aircraftError;
      }

      console.log('âœ… Inserted', insertedAircraft?.length || 0, 'sample aircraft');

      // Insert sample deals (using the IDs from inserted leads and aircraft)
      if (insertedLeads && insertedLeads.length > 0 && insertedAircraft && insertedAircraft.length > 0) {
        console.log('ðŸ’¼ Inserting sample deals...');
        const dealsToInsert = DEMO_DATA.deals.map(deal => ({
          user_id: userId,
          company_id: companyId,
          deal_name: deal.dealName,
          client_name: deal.clientName,
          related_lead: insertedLeads[0].id, // Link to first inserted lead
          related_aircraft: insertedAircraft[0].id, // Link to first inserted aircraft
          deal_value: deal.dealValue,
          estimated_closing: deal.estimatedClosing,
          status: deal.status,
          next_step: deal.nextStep,
          follow_up_date: deal.followUpDate,
          history: deal.history || [],
          timestamped_notes: []
        }));

        const { data: insertedDeals, error: dealsError } = await supabase
          .from('deals')
          .insert(dealsToInsert)
          .select();

        if (dealsError) {
          console.error('âŒ Error inserting sample deals:', dealsError);
          throw dealsError;
        }

        console.log('âœ… Inserted', insertedDeals?.length || 0, 'sample deals');

        // Insert sample tasks (related to the inserted deal and lead)
        if (insertedDeals && insertedDeals.length > 0) {
          console.log('âœ… Inserting sample tasks...');
          const tasksToInsert = DEMO_DATA.tasks.map(task => ({
            user_id: userId,
            company_id: companyId,
            title: task.title,
            description: task.description,
            due_date: task.dueDate,
            related_to: task.relatedTo?.type === 'deal'
              ? { type: 'deal', id: insertedDeals[0].id }
              : { type: 'lead', id: insertedLeads[task.relatedTo?.id === 2 ? 1 : 0]?.id },
            status: task.status,
            priority: task.priority,
            auto_generated: task.autoGenerated
          }));

          const { data: insertedTasks, error: tasksError } = await supabase
            .from('tasks')
            .insert(tasksToInsert)
            .select();

          if (tasksError) {
            console.error('âŒ Error inserting sample tasks:', tasksError);
            throw tasksError;
          }

          console.log('âœ… Inserted', insertedTasks?.length || 0, 'sample tasks');
        }
      }

      console.log('ðŸŽ‰ Sample data creation complete!');
    } catch (error) {
      console.error('âŒ Error in createSampleDataForNewCompany:', error);
      throw error;
    }
  },

  // Refresh functions for real-time updates
  refreshLeads: async () => {
    if (!get().isAuthenticated) return;

    // Only fetch minimal fields for refresh
    const leadsMinimalFields = 'id, name, company, aircraft_type, budget, budget_known, year_preference, status, presentations, timestamped_notes, created_at';
    const { data } = await supabase.from('leads').select(leadsMinimalFields);

    if (data) {
      const convertLeadMinimalFromDB = (lead) => {
        const converted = {
          id: lead.id,
          name: lead.name || '',
          company: lead.company || '',
          aircraftType: lead.aircraft_type || '',
          budget: lead.budget,
          budgetKnown: lead.budget_known || false,
          yearPreference: lead.year_preference || { oldest: null, newest: null },
          status: lead.status || 'Inquiry',
          presentations: lead.presentations || [],
          timestampedNotes: lead.timestamped_notes || [],
          createdAt: lead.created_at?.split('T')[0] || new Date().toISOString().split('T')[0],
          // Placeholder for full data
          notes: ''
        };
        return converted;
      };

      // Preserve full data for leads that have been loaded
      const { leads: currentLeads, leadsFullDataLoaded } = get();
      const newLeads = data.map(dbLead => {
        const existingLead = currentLeads.find(l => l.id === dbLead.id);
        if (existingLead && leadsFullDataLoaded.has(dbLead.id)) {
          // Keep full data for already loaded leads, but update minimal fields
          return {
            ...existingLead,
            name: dbLead.name || '',
            company: dbLead.company || '',
            aircraftType: dbLead.aircraft_type || '',
            budget: dbLead.budget,
            budgetKnown: dbLead.budget_known || false,
            yearPreference: dbLead.year_preference || { oldest: null, newest: null },
            status: dbLead.status || 'Inquiry',
            presentations: dbLead.presentations || [],
            timestampedNotes: dbLead.timestamped_notes || []
          };
        }
        return convertLeadMinimalFromDB(dbLead);
      });

      set({ leads: newLeads });
    }
  },

  refreshAircraft: async () => {
    if (!get().isAuthenticated) return;

    // Only fetch minimal fields for refresh
    const aircraftMinimalFields = 'id, manufacturer, model, yom, category, location, price, status, seller, image_url, access_type, spec_sheet, summary, presentations, created_at';
    const { data } = await supabase.from('aircraft').select(aircraftMinimalFields);

    if (data) {
      const convertAircraftMinimalFromDB = (aircraft) => ({
        id: aircraft.id,
        manufacturer: aircraft.manufacturer || '',
        model: aircraft.model || '',
        yom: aircraft.yom,
        category: aircraft.category || '',
        location: aircraft.location || '',
        price: aircraft.price || 0,
        status: aircraft.status || 'For Sale',
        seller: aircraft.seller || '',
        imageUrl: aircraft.image_url,
        accessType: aircraft.access_type || 'Direct',
        specSheet: aircraft.spec_sheet, // Include filename so UI knows if spec sheet exists
        summary: aircraft.summary || '', // AI-generated summary for display
        presentations: aircraft.presentations || [], // Which leads this was presented to
        createdAt: aircraft.created_at?.split('T')[0] || new Date().toISOString().split('T')[0],
        // Placeholders for full data
        serialNumber: null,
        registration: null,
        specSheetData: null,
        specSheetType: null,
        imageData: null,
        timestampedNotes: []
      });

      // Preserve full data for aircraft that have been loaded
      const { aircraft: currentAircraft, aircraftFullDataLoaded } = get();
      const newAircraft = data.map(dbAircraft => {
        const existingAircraft = currentAircraft.find(a => a.id === dbAircraft.id);
        if (existingAircraft && aircraftFullDataLoaded.has(dbAircraft.id)) {
          // Keep full data for already loaded aircraft, but update minimal fields
          return {
            ...existingAircraft,
            manufacturer: dbAircraft.manufacturer || '',
            model: dbAircraft.model || '',
            yom: dbAircraft.yom,
            category: dbAircraft.category || '',
            location: dbAircraft.location || '',
            price: dbAircraft.price || 0,
            status: dbAircraft.status || 'For Sale',
            seller: dbAircraft.seller || '',
            imageUrl: dbAircraft.image_url,
            accessType: dbAircraft.access_type || 'Direct',
            specSheet: dbAircraft.spec_sheet,
            summary: dbAircraft.summary || '',
            presentations: dbAircraft.presentations || []
          };
        }
        return convertAircraftMinimalFromDB(dbAircraft);
      });

      set({ aircraft: newAircraft });
    }
  },

  // Load full aircraft data on demand (lazy loading)
  loadFullAircraftData: async (aircraftId, forceReload = false) => {
    const { aircraft, aircraftFullDataLoaded, aircraftLoading, isAuthenticated } = get();

    // If not authenticated, skip
    if (!isAuthenticated) return;

    // If already loaded and not forcing reload, skip
    if (aircraftFullDataLoaded.has(aircraftId) && !forceReload) {
      console.log(`âœ… Aircraft ${aircraftId} full data already loaded (cached)`);
      const cachedAircraft = aircraft.find(a => a.id === aircraftId);
      console.log(`ðŸ“¦ Cached aircraft specSheetData exists: ${!!cachedAircraft?.specSheetData}`);
      return;
    }

    // If already loading, skip
    if (aircraftLoading.has(aircraftId)) {
      console.log(`â³ Aircraft ${aircraftId} is already being loaded`);
      return;
    }

    try {
      // Mark as loading
      const newLoading = new Set(aircraftLoading);
      newLoading.add(aircraftId);
      set({ aircraftLoading: newLoading });

      console.log(`ðŸ”„ Loading full data for aircraft ${aircraftId}...`);

      // Fetch all fields for this specific aircraft
      const { data, error } = await supabase
        .from('aircraft')
        .select('*')
        .eq('id', aircraftId)
        .single();

      if (error) throw error;

      if (data) {
        // Debug: Log what we got from the database
        console.log('ðŸ“¦ Raw data from database:', {
          id: data.id,
          spec_sheet: data.spec_sheet,
          spec_sheet_data_exists: !!data.spec_sheet_data,
          spec_sheet_data_length: data.spec_sheet_data?.length,
          spec_sheet_type: data.spec_sheet_type
        });

        // Convert to full aircraft object
        const fullAircraft = {
          id: data.id,
          manufacturer: data.manufacturer || '',
          model: data.model || '',
          yom: data.yom,
          serialNumber: data.serial_number || '',
          registration: data.registration || '',
          category: data.category || '',
          location: data.location || '',
          price: data.price || 0,
          accessType: data.access_type || 'Direct',
          summary: data.summary || '',
          status: data.status || 'For Sale',
          seller: data.seller || '',
          specSheet: data.spec_sheet,
          specSheetData: data.spec_sheet_data,
          specSheetType: data.spec_sheet_type,
          imageUrl: data.image_url,
          imageData: data.image_data,
          presentations: data.presentations || [],
          timestampedNotes: data.timestamped_notes || [],
          createdAt: data.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
        };

        console.log('âœ… Converted fullAircraft object:', {
          id: fullAircraft.id,
          specSheet: fullAircraft.specSheet,
          specSheetData_exists: !!fullAircraft.specSheetData,
          specSheetType: fullAircraft.specSheetType
        });

        // Update aircraft in state
        const updatedAircraft = aircraft.map(a => a.id === aircraftId ? fullAircraft : a);

        // Mark as loaded
        const newFullDataLoaded = new Set(aircraftFullDataLoaded);
        newFullDataLoaded.add(aircraftId);

        // Remove from loading
        const updatedLoading = new Set(aircraftLoading);
        updatedLoading.delete(aircraftId);

        set({
          aircraft: updatedAircraft,
          aircraftFullDataLoaded: newFullDataLoaded,
          aircraftLoading: updatedLoading
        });

        console.log(`âœ… Full data loaded for aircraft ${aircraftId}`);
      }
    } catch (error) {
      console.error(`âŒ Error loading full aircraft data for ${aircraftId}:`, error);

      // Remove from loading on error
      const updatedLoading = new Set(aircraftLoading);
      updatedLoading.delete(aircraftId);
      set({ aircraftLoading: updatedLoading });
    }
  },

  // Load full lead data on demand (lazy loading)
  loadFullLeadData: async (leadId) => {
    const { leads, leadsFullDataLoaded, leadsLoading, isAuthenticated } = get();

    // If not authenticated or already loaded, skip
    if (!isAuthenticated) return;
    if (leadsFullDataLoaded.has(leadId)) {
      console.log(`âœ… Lead ${leadId} full data already loaded`);
      return;
    }

    // If already loading, skip
    if (leadsLoading.has(leadId)) {
      console.log(`â³ Lead ${leadId} is already being loaded`);
      return;
    }

    try {
      // Mark as loading
      const newLoading = new Set(leadsLoading);
      newLoading.add(leadId);
      set({ leadsLoading: newLoading });

      console.log(`ðŸ”„ Loading full data for lead ${leadId}...`);

      // Fetch all fields for this specific lead
      const { data, error } = await supabase
        .from('leads')
        .select('*')
        .eq('id', leadId)
        .single();

      if (error) throw error;

      if (data) {
        // Convert to full lead object
        const fullLead = {
          id: data.id,
          name: data.name || '',
          company: data.company || '',
          aircraftType: data.aircraft_type || '',
          budget: data.budget,
          budgetKnown: data.budget_known || false,
          yearPreference: data.year_preference || { oldest: null, newest: null },
          status: data.status || 'Inquiry',
          notes: data.notes || '',
          presentations: data.presentations || [],
          timestampedNotes: data.timestamped_notes || [],
          createdAt: data.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
        };

        // Update lead in state
        const updatedLeads = leads.map(l => l.id === leadId ? fullLead : l);

        // Mark as loaded
        const newFullDataLoaded = new Set(leadsFullDataLoaded);
        newFullDataLoaded.add(leadId);

        // Remove from loading
        const updatedLoading = new Set(leadsLoading);
        updatedLoading.delete(leadId);

        set({
          leads: updatedLeads,
          leadsFullDataLoaded: newFullDataLoaded,
          leadsLoading: updatedLoading
        });

        console.log(`âœ… Full data loaded for lead ${leadId}`);
      }
    } catch (error) {
      console.error(`âŒ Error loading full lead data for ${leadId}:`, error);

      // Remove from loading on error
      const updatedLoading = new Set(leadsLoading);
      updatedLoading.delete(leadId);
      set({ leadsLoading: updatedLoading });
    }
  },

  // Load full deal data on demand (lazy loading)
  loadFullDealData: async (dealId) => {
    const { deals, dealsFullDataLoaded, dealsLoading, isAuthenticated } = get();

    // If not authenticated or already loaded, skip
    if (!isAuthenticated) return;
    if (dealsFullDataLoaded.has(dealId)) {
      console.log(`âœ… Deal ${dealId} full data already loaded`);
      return;
    }

    // If already loading, skip
    if (dealsLoading.has(dealId)) {
      console.log(`â³ Deal ${dealId} is already being loaded`);
      return;
    }

    try {
      // Mark as loading
      const newLoading = new Set(dealsLoading);
      newLoading.add(dealId);
      set({ dealsLoading: newLoading });

      console.log(`ðŸ”„ Loading full data for deal ${dealId}...`);

      // Fetch all fields for this specific deal
      const { data, error } = await supabase
        .from('deals')
        .select('*')
        .eq('id', dealId)
        .single();

      if (error) throw error;

      if (data) {
        // Convert to full deal object
        const fullDeal = {
          id: data.id,
          dealName: data.deal_name || '',
          clientName: data.client_name || '',
          relatedLead: data.related_lead,
          relatedAircraft: data.related_aircraft,
          dealValue: data.deal_value || 0,
          estimatedClosing: data.estimated_closing || '',
          status: data.status || 'LOI Signed',
          nextStep: data.next_step || '',
          followUpDate: data.follow_up_date || '',
          document: data.document,
          documentData: data.document_data,
          documentType: data.document_type,
          history: data.history || [],
          timestampedNotes: data.timestamped_notes || [],
          timeline: data.timeline,
          timelineGenerated: data.timeline_generated,
          documentParsed: data.document_parsed,
          createdAt: data.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
        };

        // Update deal in state
        const updatedDeals = deals.map(d => d.id === dealId ? fullDeal : d);

        // Mark as loaded
        const newFullDataLoaded = new Set(dealsFullDataLoaded);
        newFullDataLoaded.add(dealId);

        // Remove from loading
        const updatedLoading = new Set(dealsLoading);
        updatedLoading.delete(dealId);

        set({
          deals: updatedDeals,
          dealsFullDataLoaded: newFullDataLoaded,
          dealsLoading: updatedLoading
        });

        console.log(`âœ… Full data loaded for deal ${dealId}`);
      }
    } catch (error) {
      console.error(`âŒ Error loading full deal data for ${dealId}:`, error);

      // Remove from loading on error
      const updatedLoading = new Set(dealsLoading);
      updatedLoading.delete(dealId);
      set({ dealsLoading: updatedLoading });
    }
  },

  refreshDeals: async () => {
    if (!get().isAuthenticated) return;

    // Only fetch minimal fields for refresh
    const dealsMinimalFields = 'id, deal_name, client_name, related_lead, related_aircraft, deal_value, estimated_closing, status, next_step, follow_up_date, created_at';
    const { data } = await supabase.from('deals').select(dealsMinimalFields);

    if (data) {
      const convertDealMinimalFromDB = (deal) => {
        return {
          id: deal.id,
          dealName: deal.deal_name || '',
          clientName: deal.client_name || '',
          relatedLead: deal.related_lead,
          relatedAircraft: deal.related_aircraft,
          dealValue: deal.deal_value || 0,
          estimatedClosing: deal.estimated_closing || '',
          status: deal.status || 'LOI Signed',
          nextStep: deal.next_step || '',
          followUpDate: deal.follow_up_date || '',
          createdAt: deal.created_at?.split('T')[0] || new Date().toISOString().split('T')[0],
          // Placeholders for full data
          document: null,
          documentData: null,
          documentType: null,
          history: [],
          timestampedNotes: [],
          timeline: null,
          timelineGenerated: null,
          documentParsed: null
        };
      };

      // Preserve full data for deals that have been loaded
      const { deals: currentDeals, dealsFullDataLoaded } = get();
      const newDeals = data.map(dbDeal => {
        const existingDeal = currentDeals.find(d => d.id === dbDeal.id);
        if (existingDeal && dealsFullDataLoaded.has(dbDeal.id)) {
          // Keep full data for already loaded deals, but update minimal fields
          return {
            ...existingDeal,
            dealName: dbDeal.deal_name || '',
            clientName: dbDeal.client_name || '',
            relatedLead: dbDeal.related_lead,
            relatedAircraft: dbDeal.related_aircraft,
            dealValue: dbDeal.deal_value || 0,
            estimatedClosing: dbDeal.estimated_closing || '',
            status: dbDeal.status || 'LOI Signed',
            nextStep: dbDeal.next_step || '',
            followUpDate: dbDeal.follow_up_date || ''
          };
        }
        return convertDealMinimalFromDB(dbDeal);
      });

      set({ deals: newDeals });
    }
  },

  refreshTasks: async () => {
    if (!get().isAuthenticated) return;
    const { data } = await supabase.from('tasks').select('*');
    if (data) {
      const convertTaskFromDB = (task) => ({
        id: task.id,
        title: task.title || '',
        description: task.description || '',
        dueDate: task.due_date || '',
        relatedTo: task.related_to || null,
        status: task.status || 'pending',
        priority: task.priority || 'medium',
        autoGenerated: task.auto_generated || false,
        createdAt: task.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
      });
      set({ tasks: data.map(convertTaskFromDB) });
    }
  },

  // Helper to save to localStorage in demo mode
  saveToLocalStorage: () => {
    // Disabled - only using Supabase, no localStorage
    return;
  },

  // Multi-Tenant Functions
  // Load current user's profile and company info
  loadUserProfile: async () => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return null;

    const { data: profile } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single();

    if (profile) {
      // Load company separately
      const { data: company } = await supabase
        .from('companies')
        .select('*')
        .eq('id', profile.company_id)
        .single();

      set({ currentUserProfile: { ...profile, company } });
      return { ...profile, company };
    }

    return null;
  },

  // Update current user's profile
  updateUserProfile: async (updates) => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('Not authenticated');

    const { error } = await supabase
      .from('profiles')
      .update({
        first_name: updates.first_name,
        last_name: updates.last_name
      })
      .eq('id', user.id);

    if (error) throw error;

    // Reload profile to update state
    await get().loadUserProfile();
  },

  // Load all users in the company (admin only)
  loadCompanyUsers: async () => {
    const profile = get().currentUserProfile;
    if (!profile || profile.role !== 'admin') return;

    // Use database function to get company users (bypasses RLS)
    const { data: profiles, error } = await supabase
      .rpc('get_company_users');

    if (error) {
      console.error('Error loading company users:', error);
      return;
    }

    // Map profiles to user objects
    const users = (profiles || []).map(p => ({
      id: p.id,
      email: p.email || 'no-email@example.com',
      firstName: p.first_name,
      lastName: p.last_name,
      role: p.role,
      active: p.active
    }));

    set({ companyUsers: users });
  },

  // Invite new user to company
  inviteUser: async (userData) => {
    const profile = get().currentUserProfile;
    if (!profile || profile.role !== 'admin') {
      throw new Error('Only admins can invite users');
    }

    // Check if user is already in the company
    const { data: existingUser } = await supabase
      .from('profiles')
      .select('id, email, active')
      .eq('company_id', profile.company_id)
      .eq('email', userData.email)
      .single();

    if (existingUser) {
      if (existingUser.active) {
        throw new Error(`${userData.email} is already a member of your company.`);
      } else {
        throw new Error(`${userData.email} was previously a member. Please contact support to reactivate this user.`);
      }
    }

    // Check if an invitation already exists
    const { data: existingInvitation } = await supabase
      .from('user_invitations')
      .select('*')
      .eq('company_id', profile.company_id)
      .eq('email', userData.email)
      .single();

    let invitationData;
    let isResend = false;

    if (existingInvitation) {
      // Check if invitation is expired
      const isExpired = new Date(existingInvitation.expires_at) < new Date();
      const isPending = existingInvitation.status === 'pending';

      if (existingInvitation.status === 'accepted') {
        throw new Error(`An invitation for ${userData.email} was already accepted. The user should already be in your company.`);
      }

      if (isPending && !isExpired) {
        // Invitation is still valid - resend email
        invitationData = existingInvitation;
        isResend = true;
      } else {
        // Invitation is expired or cancelled - delete and create new one
        await supabase
          .from('user_invitations')
          .delete()
          .eq('id', existingInvitation.id);
      }
    }

    // Check if company can add more users (5 user limit)
    const { data: canAddUser, error: checkError } = await supabase
      .rpc('can_add_user_to_company', { p_company_id: profile.company_id });

    if (checkError) {
      console.error('Error checking user limit:', checkError);
      throw new Error('Failed to verify company user limit');
    }

    if (!canAddUser) {
      throw new Error('Your company has reached the maximum limit of 5 users. Please contact support to increase your limit.');
    }

    // Create new invitation if we don't have one to resend
    if (!invitationData) {
      const token = crypto.randomUUID();

      const { data, error } = await supabase
        .from('user_invitations')
        .insert({
          company_id: profile.company_id,
          email: userData.email,
          invited_by: profile.id,
          role: userData.role || 'user',
          token: token
        })
        .select()
        .single();

      if (error) {
        // Check if error is due to user limit
        if (error.message && error.message.includes('maximum limit')) {
          throw new Error(error.message);
        }
        throw error;
      }

      invitationData = data;
    }

    // Send invitation email automatically
    try {
      const { data: { session } } = await supabase.auth.getSession();

      const response = await supabase.functions.invoke('send-invitation-email', {
        body: { invitationId: invitationData.id },
        headers: {
          Authorization: `Bearer ${session?.access_token}`
        }
      });

      if (response.error) {
        console.error('Error sending invitation email:', response.error);
        // Don't throw - invitation was created, just email failed
        alert(`Invitation ${isResend ? 'exists' : 'created'} for ${userData.email}, but email delivery failed. Please contact them directly with this link:\n${window.location.origin}?invitation=${invitationData.token}`);
      } else {
        alert(`Invitation ${isResend ? 'resent' : 'sent'} successfully! An email has been sent to ${userData.email} with instructions to join your team.`);
      }
    } catch (emailError) {
      console.error('Failed to send invitation email:', emailError);
      // Fallback to manual link sharing
      const invitationUrl = `${window.location.origin}?invitation=${invitationData.token}`;
      try {
        await navigator.clipboard.writeText(invitationUrl);
        alert(`Invitation ${isResend ? 'exists' : 'created'}, but automated email failed.\n\nInvitation link copied to clipboard:\n${invitationUrl}\n\nPlease send this link to ${userData.email} manually.`);
      } catch (clipboardError) {
        alert(`Invitation ${isResend ? 'exists' : 'created'}, but automated email failed.\n\nPlease send this link to ${userData.email}:\n${invitationUrl}`);
      }
    }

    return invitationData;
  },

  // Update user role (admin only)
  updateUserRole: async (userId, newRole) => {
    const profile = get().currentUserProfile;
    if (!profile || profile.role !== 'admin') {
      throw new Error('Only admins can update user roles');
    }

    const { error } = await supabase
      .from('profiles')
      .update({ role: newRole })
      .eq('id', userId)
      .eq('company_id', profile.company_id);

    if (error) throw error;
  },

  // Delete user (admin only)
  deleteUser: async (userId) => {
    const profile = get().currentUserProfile;
    if (!profile || profile.role !== 'admin') {
      throw new Error('Only admins can delete users');
    }

    // Deactivate instead of delete to preserve data integrity
    const { error } = await supabase
      .from('profiles')
      .update({ active: false })
      .eq('id', userId)
      .eq('company_id', profile.company_id);

    if (error) throw error;
  },

  // Lead Actions
  addLead: async (leadData) => {
    const { leads, createAutoTask, isAuthenticated, currentUser, currentUserProfile, saveToLocalStorage } = get();

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      const newLead = {
        id: Math.max(0, ...leads.map(l => l.id)) + 1,
        name: '',
        company: '',
        aircraftType: '',
        budget: null,
        budgetKnown: false,
        yearPreference: { oldest: null, newest: null },
        status: 'Inquiry',
        notes: '',
        ...leadData,
        presentations: [],
        timestampedNotes: [],
        createdAt: new Date().toISOString().split('T')[0]
      };
      set({ leads: [...leads, newLead] });
      saveToLocalStorage();
      if (newLead.name) {
        createAutoTask('lead', newLead.id, `Follow up with ${newLead.name}`);
      }
      return newLead;
    }

    // Supabase mode
    try {
      const { data, error } = await supabase
        .from('leads')
        .insert([{
          user_id: currentUser.id,
          company_id: currentUserProfile?.company_id,
          name: leadData.name || '',
          company: leadData.company || '',
          aircraft_type: leadData.aircraftType || '',
          budget: leadData.budget,
          budget_known: leadData.budgetKnown || false,
          year_preference: leadData.yearPreference || { oldest: null, newest: null },
          status: leadData.status || 'Inquiry',
          notes: leadData.notes || '',
          presentations: [],
          timestamped_notes: []
        }])
        .select()
        .single();

      if (error) throw error;

      const newLead = {
        id: data.id,
        name: data.name || '',
        company: data.company || '',
        aircraftType: data.aircraft_type || '',
        budget: data.budget,
        budgetKnown: data.budget_known || false,
        yearPreference: data.year_preference || { oldest: null, newest: null },
        status: data.status || 'Inquiry',
        notes: data.notes || '',
        presentations: data.presentations || [],
        timestampedNotes: data.timestamped_notes || [],
        createdAt: data.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
      };

      set({ leads: [...leads, newLead] });

      if (newLead.name) {
        createAutoTask('lead', newLead.id, `Follow up with ${newLead.name}`);
      }

      return newLead;
    } catch (error) {
      console.error('Error adding lead:', error);
      throw error;
    }
  },

  updateLead: async (id, updatedData) => {
    console.log('ðŸ”„ updateLead called:', { id, updatedData });
    const { leads, isAuthenticated, saveToLocalStorage } = get();

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      set({ leads: leads.map(lead => lead.id === id ? { ...lead, ...updatedData } : lead) });
      saveToLocalStorage();
      return;
    }

    // Supabase mode
    try {
      const dbData = {};
      if (updatedData.name !== undefined) dbData.name = updatedData.name;
      if (updatedData.company !== undefined) dbData.company = updatedData.company;
      if (updatedData.aircraftType !== undefined) dbData.aircraft_type = updatedData.aircraftType;
      if (updatedData.budget !== undefined) dbData.budget = updatedData.budget;
      if (updatedData.budgetKnown !== undefined) dbData.budget_known = updatedData.budgetKnown;
      if (updatedData.yearPreference !== undefined) dbData.year_preference = updatedData.yearPreference;
      if (updatedData.status !== undefined) dbData.status = updatedData.status;
      if (updatedData.notes !== undefined) dbData.notes = updatedData.notes;
      if (updatedData.presentations !== undefined) dbData.presentations = updatedData.presentations;
      if (updatedData.timestampedNotes !== undefined) dbData.timestamped_notes = updatedData.timestampedNotes;

      console.log('ðŸ“¤ Sending to Supabase:', { id, dbData });

      const { data, error } = await supabase
        .from('leads')
        .update(dbData)
        .eq('id', id)
        .select();

      if (error) {
        console.error('âŒ Supabase update failed:', error);
        throw error;
      }

      console.log('âœ… Supabase update successful:', data);

      // Verify the update by fetching the record
      const { data: verifyData, error: verifyError } = await supabase
        .from('leads')
        .select('*')
        .eq('id', id)
        .single();

      if (verifyError) {
        console.error('âŒ Failed to verify update:', verifyError);
      } else {
        console.log('ðŸ” Verified data in database:', verifyData);
      }

      set({ leads: leads.map(lead => lead.id === id ? { ...lead, ...updatedData } : lead) });
    } catch (error) {
      console.error('âŒ Error updating lead:', error);
      throw error;
    }
  },

  deleteLead: async (id) => {
    const { leads, isAuthenticated, saveToLocalStorage } = get();

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      set({ leads: leads.filter(lead => lead.id !== id) });
      saveToLocalStorage();
      return;
    }

    // Supabase mode
    try {
      const { error } = await supabase
        .from('leads')
        .delete()
        .eq('id', id);

      if (error) throw error;

      set({ leads: leads.filter(lead => lead.id !== id) });
    } catch (error) {
      console.error('Error deleting lead:', error);
      throw error;
    }
  },

  // Aircraft Actions
  addAircraft: async (aircraftData) => {
    const { aircraft, isAuthenticated, currentUser, currentUserProfile, saveToLocalStorage } = get();

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      const newAircraft = {
        id: Math.max(0, ...aircraft.map(a => a.id)) + 1,
        manufacturer: '',
        model: '',
        yom: null,
        serialNumber: '',
        registration: '',
        category: '',
        location: '',
        price: 0,
        accessType: 'Direct',
        specSheet: null,
        specSheetData: null,
        specSheetType: null,
        imageUrl: null,
        imageData: null,
        ...aircraftData,
        presentations: [],
        timestampedNotes: [],
        createdAt: new Date().toISOString().split('T')[0]
      };
      set({ aircraft: [...aircraft, newAircraft] });
      saveToLocalStorage();
      return newAircraft;
    }

    // Supabase mode
    try {
      const { data, error } = await supabase
        .from('aircraft')
        .insert([{
          user_id: currentUser.id,
          company_id: currentUserProfile?.company_id,
          manufacturer: aircraftData.manufacturer || '',
          model: aircraftData.model || '',
          yom: aircraftData.yom,
          serial_number: aircraftData.serialNumber || '',
          registration: aircraftData.registration || '',
          category: aircraftData.category || '',
          location: aircraftData.location || '',
          price: aircraftData.price || 0,
          access_type: aircraftData.accessType || 'Direct',
          summary: aircraftData.summary || null,
          status: aircraftData.status || 'For Sale',
          seller: aircraftData.seller || null,
          total_time: aircraftData.totalTime || null,
          range: aircraftData.range || null,
          pax: aircraftData.pax || null,
          spec_sheet: aircraftData.specSheet,
          spec_sheet_data: aircraftData.specSheetData,
          spec_sheet_type: aircraftData.specSheetType,
          image_url: aircraftData.imageUrl,
          image_data: aircraftData.imageData,
          presentations: [],
          timestamped_notes: []
        }])
        .select()
        .single();

      if (error) {
        console.error('Supabase error details:', error);
        console.error('Error code:', error.code);
        console.error('Error message:', error.message);
        console.error('Error details:', error.details);
        throw error;
      }

      const newAircraft = {
        id: data.id,
        manufacturer: data.manufacturer || '',
        model: data.model || '',
        yom: data.yom,
        serialNumber: data.serial_number || '',
        registration: data.registration || '',
        category: data.category || '',
        location: data.location || '',
        price: data.price || 0,
        accessType: data.access_type || 'Direct',
        summary: data.summary || '',
        status: data.status || 'For Sale',
        seller: data.seller || '',
        totalTime: data.total_time,
        range: data.range,
        pax: data.pax,
        specSheet: data.spec_sheet,
        specSheetData: data.spec_sheet_data,
        specSheetType: data.spec_sheet_type,
        imageUrl: data.image_url,
        imageData: data.image_data,
        presentations: data.presentations || [],
        timestampedNotes: data.timestamped_notes || [],
        createdAt: data.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
      };

      set({ aircraft: [...aircraft, newAircraft] });
      return newAircraft;
    } catch (error) {
      console.error('Error adding aircraft:', error);
      console.error('Full error object:', JSON.stringify(error, null, 2));
      throw error;
    }
  },

  updateAircraft: async (id, updatedData) => {
    const { aircraft, isAuthenticated, saveToLocalStorage } = get();

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      set({ aircraft: aircraft.map(ac => ac.id === id ? { ...ac, ...updatedData } : ac) });
      saveToLocalStorage();
      return;
    }

    // Supabase mode
    try {
      const dbData = {};
      if (updatedData.manufacturer !== undefined) dbData.manufacturer = updatedData.manufacturer;
      if (updatedData.model !== undefined) dbData.model = updatedData.model;
      if (updatedData.yom !== undefined) dbData.yom = updatedData.yom;
      if (updatedData.serialNumber !== undefined) dbData.serial_number = updatedData.serialNumber;
      if (updatedData.registration !== undefined) dbData.registration = updatedData.registration;
      if (updatedData.category !== undefined) dbData.category = updatedData.category;
      if (updatedData.location !== undefined) dbData.location = updatedData.location;
      if (updatedData.price !== undefined) dbData.price = updatedData.price;
      if (updatedData.accessType !== undefined) dbData.access_type = updatedData.accessType;
      if (updatedData.summary !== undefined) dbData.summary = updatedData.summary;
      if (updatedData.status !== undefined) dbData.status = updatedData.status;
      if (updatedData.seller !== undefined) dbData.seller = updatedData.seller;
      if (updatedData.specSheet !== undefined) dbData.spec_sheet = updatedData.specSheet;
      if (updatedData.specSheetData !== undefined) dbData.spec_sheet_data = updatedData.specSheetData;
      if (updatedData.specSheetType !== undefined) dbData.spec_sheet_type = updatedData.specSheetType;
      if (updatedData.imageUrl !== undefined) dbData.image_url = updatedData.imageUrl;
      if (updatedData.imageData !== undefined) dbData.image_data = updatedData.imageData;
      if (updatedData.presentations !== undefined) dbData.presentations = updatedData.presentations;
      if (updatedData.timestampedNotes !== undefined) dbData.timestamped_notes = updatedData.timestampedNotes;

      const { error } = await supabase
        .from('aircraft')
        .update(dbData)
        .eq('id', id);

      if (error) throw error;

      set({ aircraft: aircraft.map(ac => ac.id === id ? { ...ac, ...updatedData } : ac) });
    } catch (error) {
      console.error('Error updating aircraft:', error);
      throw error;
    }
  },

  deleteAircraft: async (id) => {
    const { aircraft, isAuthenticated, saveToLocalStorage } = get();

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      set({ aircraft: aircraft.filter(ac => ac.id !== id) });
      saveToLocalStorage();
      return;
    }

    // Supabase mode
    try {
      const { error } = await supabase
        .from('aircraft')
        .delete()
        .eq('id', id);

      if (error) throw error;

      set({ aircraft: aircraft.filter(ac => ac.id !== id) });
    } catch (error) {
      console.error('Error deleting aircraft:', error);
      throw error;
    }
  },

  // Deal Actions
  addDeal: async (dealData) => {
    const { deals, leads, createAutoTask, isAuthenticated, currentUser, currentUserProfile, saveToLocalStorage } = get();

    const history = [{ date: new Date().toISOString(), action: 'Deal created', status: dealData.status || 'LOI Signed' }];

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      const newDeal = {
        id: Math.max(0, ...deals.map(d => d.id)) + 1,
        dealName: '',
        clientName: '',
        relatedLead: null,
        relatedAircraft: null,
        dealValue: 0,
        estimatedClosing: '',
        status: 'LOI Signed',
        nextStep: '',
        followUpDate: '',
        document: null,
        documentData: null,
        documentType: null,
        ...dealData,
        createdAt: new Date().toISOString().split('T')[0],
        history,
        timestampedNotes: []
      };
      set({ deals: [...deals, newDeal] });
      saveToLocalStorage();
      if (newDeal.nextStep && newDeal.followUpDate) {
        // Create task with format "Next Step - Deal Name"
        const taskTitle = `${newDeal.nextStep} - ${newDeal.dealName}`;
        createAutoTask('deal', newDeal.id, taskTitle, newDeal.followUpDate);
      }
      return newDeal;
    }

    // Supabase mode
    try {
      // Build the insert data object, filtering out undefined values
      const insertData = {
        user_id: currentUser.id,
        company_id: currentUserProfile?.company_id,
        deal_name: dealData.dealName || '',
        client_name: dealData.clientName || '',
        related_lead: dealData.relatedLead || null,
        deal_value: dealData.dealValue || 0,
        estimated_closing: dealData.estimatedClosing || '',
        status: dealData.status || 'LOI Signed',
        next_step: dealData.nextStep || '',
        follow_up_date: dealData.followUpDate || '',
        history,
        timestamped_notes: []
      };

      // Only add optional fields if they have values
      if (dealData.relatedAircraft) {
        insertData.related_aircraft = dealData.relatedAircraft;
      }
      if (dealData.document) {
        insertData.document = dealData.document;
      }
      if (dealData.documentData) {
        insertData.document_data = dealData.documentData;
      }
      if (dealData.documentType) {
        insertData.document_type = dealData.documentType;
      }

      console.log('ðŸ’¾ Inserting deal:', insertData);

      const { data, error } = await supabase
        .from('deals')
        .insert([insertData])
        .select()
        .single();

      if (error) {
        console.error('âŒ Supabase insert error:', {
          message: error.message,
          details: error.details,
          hint: error.hint,
          code: error.code
        });
        throw error;
      }

      console.log('âœ… Deal created successfully:', data);

      const newDeal = {
        id: data.id,
        dealName: data.deal_name || '',
        clientName: data.client_name || '',
        relatedLead: data.related_lead,
        relatedAircraft: data.related_aircraft,
        dealValue: data.deal_value || 0,
        estimatedClosing: data.estimated_closing || '',
        status: data.status || 'Lead',
        nextStep: data.next_step || '',
        followUpDate: data.follow_up_date || '',
        document: data.document,
        documentData: data.document_data,
        documentType: data.document_type,
        history: data.history || [],
        timestampedNotes: data.timestamped_notes || [],
        timeline: data.timeline,
        timelineGenerated: data.timeline_generated,
        documentParsed: data.document_parsed,
        createdAt: data.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
      };

      set({ deals: [...deals, newDeal] });

      // If deal was created from a lead, update the lead's status to "Deal Created"
      if (dealData.relatedLead) {
        console.log('ðŸŽ¯ Updating lead status to "Deal Created" after deal creation');
        try {
          await supabase
            .from('leads')
            .update({ status: 'Deal Created' })
            .eq('id', dealData.relatedLead);

          // Update local state
          set({
            leads: leads.map(l =>
              l.id === dealData.relatedLead
                ? { ...l, status: 'Deal Created' }
                : l
            )
          });
          console.log('âœ… Lead status updated to "Deal Created"');
        } catch (error) {
          console.error('Error updating lead status:', error);
        }
      }

      if (newDeal.nextStep && newDeal.followUpDate) {
        // Create task with format "Next Step - Deal Name"
        const taskTitle = `${newDeal.nextStep} - ${newDeal.dealName}`;
        createAutoTask('deal', newDeal.id, taskTitle, newDeal.followUpDate);
      }

      return newDeal;
    } catch (error) {
      console.error('âŒ Error adding deal:', {
        message: error.message,
        details: error.details,
        hint: error.hint,
        code: error.code,
        fullError: error
      });
      throw error;
    }
  },

  updateDeal: async (id, updatedData) => {
    const { deals, isAuthenticated, saveToLocalStorage } = get();

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      set({ deals: deals.map(d => d.id === id ? { ...d, ...updatedData } : d) });
      saveToLocalStorage();
      return;
    }

    // Supabase mode
    try {
      const dbData = {};
      if (updatedData.dealName !== undefined) dbData.deal_name = updatedData.dealName;
      if (updatedData.clientName !== undefined) dbData.client_name = updatedData.clientName;
      if (updatedData.relatedLead !== undefined) dbData.related_lead = updatedData.relatedLead;
      if (updatedData.relatedAircraft !== undefined) dbData.related_aircraft = updatedData.relatedAircraft;
      if (updatedData.dealValue !== undefined) dbData.deal_value = updatedData.dealValue;
      if (updatedData.estimatedClosing !== undefined) dbData.estimated_closing = updatedData.estimatedClosing;
      if (updatedData.status !== undefined) dbData.status = updatedData.status;
      if (updatedData.nextStep !== undefined) dbData.next_step = updatedData.nextStep;
      if (updatedData.followUpDate !== undefined) dbData.follow_up_date = updatedData.followUpDate;
      if (updatedData.document !== undefined) dbData.document = updatedData.document;
      if (updatedData.documentData !== undefined) dbData.document_data = updatedData.documentData;
      if (updatedData.documentType !== undefined) dbData.document_type = updatedData.documentType;
      if (updatedData.history !== undefined) dbData.history = updatedData.history;
      if (updatedData.timestampedNotes !== undefined) dbData.timestamped_notes = updatedData.timestampedNotes;
      if (updatedData.timeline !== undefined) dbData.timeline = updatedData.timeline;
      if (updatedData.timelineGenerated !== undefined) dbData.timeline_generated = updatedData.timelineGenerated;
      if (updatedData.documentParsed !== undefined) dbData.document_parsed = updatedData.documentParsed;

      console.log('ðŸ’¾ Updating deal in Supabase:', id);
      console.log('  - Updating document:', dbData.document);
      console.log('  - Updating document_data:', dbData.document_data ? `${dbData.document_data.length} chars` : 'null');

      const { error } = await supabase
        .from('deals')
        .update(dbData)
        .eq('id', id);

      if (error) throw error;

      set({ deals: deals.map(d => d.id === id ? { ...d, ...updatedData } : d) });
    } catch (error) {
      console.error('Error updating deal:', error);
      throw error;
    }
  },

  updateDealStatus: async (id, newStatus) => {
    const { deals, isAuthenticated, saveToLocalStorage } = get();
    const deal = deals.find(d => d.id === id);

    const nextSteps = {
      'LOI Signed': { step: 'Collect deposit payment', days: 3 },
      'Deposit Paid': { step: 'Draft Aircraft Purchase Agreement', days: 5 },
      'APA Drafted': { step: 'Review and sign APA', days: 7 },
      'APA Signed': { step: 'Schedule pre-purchase inspection', days: 3 },
      'PPI Started': { step: 'Review inspection findings', days: 14 },
      'Defect Rectifications': { step: 'Complete repairs and re-inspect', days: 10 },
      'Closing': { step: 'Finalize paperwork and payment', days: 7 },
      'Closed Won': { step: 'Post-sale follow-up', days: 30 },
      'Closed Lost': { step: 'Archive and analyze', days: 1 }
    };

    const nextStep = nextSteps[newStatus];
    const followUpDate = new Date();
    followUpDate.setDate(followUpDate.getDate() + nextStep.days);

    const updatedDeal = {
      ...deal,
      status: newStatus,
      nextStep: nextStep.step,
      followUpDate: followUpDate.toISOString().split('T')[0],
      history: [...deal.history, {
        date: new Date().toISOString(),
        action: `Status changed to ${newStatus}`,
        status: newStatus
      }]
    };

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      set({ deals: deals.map(d => d.id === id ? updatedDeal : d) });
      saveToLocalStorage();
      get().createAutoTask('deal', id, nextStep.step, followUpDate.toISOString().split('T')[0]);
      return;
    }

    // Supabase mode
    try {
      const { error } = await supabase
        .from('deals')
        .update({
          status: newStatus,
          next_step: nextStep.step,
          follow_up_date: followUpDate.toISOString().split('T')[0],
          history: updatedDeal.history
        })
        .eq('id', id);

      if (error) throw error;

      set({ deals: deals.map(d => d.id === id ? updatedDeal : d) });
      get().createAutoTask('deal', id, nextStep.step, followUpDate.toISOString().split('T')[0]);
    } catch (error) {
      console.error('Error updating deal status:', error);
      throw error;
    }
  },

  deleteDeal: async (id) => {
    const { deals, isAuthenticated, saveToLocalStorage } = get();

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      set({ deals: deals.filter(deal => deal.id !== id) });
      saveToLocalStorage();
      return;
    }

    // Supabase mode
    try {
      const { error } = await supabase
        .from('deals')
        .delete()
        .eq('id', id);

      if (error) throw error;

      set({ deals: deals.filter(deal => deal.id !== id) });
    } catch (error) {
      console.error('Error deleting deal:', error);
      throw error;
    }
  },

  // Task Actions
  addTask: async (taskData) => {
    const { tasks, isAuthenticated, currentUser, currentUserProfile, saveToLocalStorage } = get();

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      const newTask = {
        id: Math.max(0, ...tasks.map(t => t.id)) + 1,
        ...taskData,
        createdAt: new Date().toISOString().split('T')[0],
        autoGenerated: false
      };
      set({ tasks: [...tasks, newTask] });
      saveToLocalStorage();
      return newTask;
    }

    // Supabase mode
    try {
      // Validate and fix date - convert empty string to null
      const validDueDate = taskData.dueDate && taskData.dueDate.trim() !== '' ? taskData.dueDate : null;

      const { data, error } = await supabase
        .from('tasks')
        .insert([{
          user_id: currentUser.id,
          company_id: currentUserProfile?.company_id,
          title: taskData.title || '',
          description: taskData.description || '',
          due_date: validDueDate,
          related_to: taskData.relatedTo || null,
          status: taskData.status || 'pending',
          priority: taskData.priority || 'medium',
          auto_generated: taskData.autoGenerated || false
        }])
        .select()
        .single();

      if (error) throw error;

      const newTask = {
        id: data.id,
        title: data.title || '',
        description: data.description || '',
        dueDate: data.due_date || '',
        relatedTo: data.related_to || null,
        status: data.status || 'pending',
        priority: data.priority || 'medium',
        autoGenerated: data.auto_generated || false,
        createdAt: data.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
      };

      set({ tasks: [...tasks, newTask] });
      return newTask;
    } catch (error) {
      console.error('Error adding task:', error);
      throw error;
    }
  },

  updateTask: async (id, updatedData) => {
    const { tasks, isAuthenticated, saveToLocalStorage } = get();

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      set({ tasks: tasks.map(task => task.id === id ? { ...task, ...updatedData } : task) });
      saveToLocalStorage();
      return;
    }

    // Supabase mode
    try {
      const dbData = {};
      if (updatedData.title !== undefined) dbData.title = updatedData.title;
      if (updatedData.description !== undefined) dbData.description = updatedData.description;
      if (updatedData.dueDate !== undefined) dbData.due_date = updatedData.dueDate;
      if (updatedData.relatedTo !== undefined) dbData.related_to = updatedData.relatedTo;
      if (updatedData.status !== undefined) dbData.status = updatedData.status;
      if (updatedData.priority !== undefined) dbData.priority = updatedData.priority;
      if (updatedData.autoGenerated !== undefined) dbData.auto_generated = updatedData.autoGenerated;

      const { error } = await supabase
        .from('tasks')
        .update(dbData)
        .eq('id', id);

      if (error) throw error;

      set({ tasks: tasks.map(task => task.id === id ? { ...task, ...updatedData } : task) });
    } catch (error) {
      console.error('Error updating task:', error);
      throw error;
    }
  },

  deleteTask: async (id) => {
    const { tasks, isAuthenticated, saveToLocalStorage } = get();

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      set({ tasks: tasks.filter(task => task.id !== id) });
      saveToLocalStorage();
      return;
    }

    // Supabase mode
    try {
      const { error } = await supabase
        .from('tasks')
        .delete()
        .eq('id', id);

      if (error) throw error;

      set({ tasks: tasks.filter(task => task.id !== id) });
    } catch (error) {
      console.error('Error deleting task:', error);
      throw error;
    }
  },

  createAutoTask: async (type, relatedId, title, dueDate = null) => {
    const { tasks, isAuthenticated, currentUser, currentUserProfile, saveToLocalStorage } = get();
    const taskDueDate = dueDate || new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

    // Demo mode - use localStorage
    if (!isAuthenticated) {
      const newTask = {
        id: Math.max(0, ...tasks.map(t => t.id)) + 1,
        title,
        description: `Auto-generated task for ${type}`,
        dueDate: taskDueDate,
        relatedTo: { type, id: relatedId },
        status: 'pending',
        priority: 'medium',
        createdAt: new Date().toISOString().split('T')[0],
        autoGenerated: true
      };
      set({ tasks: [...tasks, newTask] });
      saveToLocalStorage();
      return newTask;
    }

    // Supabase mode
    try {
      const { data, error } = await supabase
        .from('tasks')
        .insert([{
          user_id: currentUser.id,
          company_id: currentUserProfile?.company_id,
          title,
          description: `Auto-generated task for ${type}`,
          due_date: taskDueDate,
          related_to: { type, id: relatedId },
          status: 'pending',
          priority: 'medium',
          auto_generated: true
        }])
        .select()
        .single();

      if (error) throw error;

      const newTask = {
        id: data.id,
        title: data.title || '',
        description: data.description || '',
        dueDate: data.due_date || '',
        relatedTo: data.related_to || null,
        status: data.status || 'pending',
        priority: data.priority || 'medium',
        autoGenerated: data.auto_generated || false,
        createdAt: data.created_at?.split('T')[0] || new Date().toISOString().split('T')[0]
      };

      set({ tasks: [...tasks, newTask] });
      return newTask;
    } catch (error) {
      console.error('Error creating auto task:', error);
      // Don't throw error for auto-generated tasks
      return null;
    }
  },

  // Presentation Actions
  presentAircraftToLead: async (leadId, aircraftId, notes, price) => {
    const { leads, aircraft, createAutoTask, isAuthenticated } = get();

    const presentation = {
      aircraftId,
      date: new Date().toISOString(),
      notes,
      priceGiven: price
    };

    const lead = leads.find(l => l.id === leadId);
    const updatedLeadPresentations = [...(lead?.presentations || []), presentation];

    const ac = aircraft.find(a => a.id === aircraftId);
    const updatedAircraftPresentations = [...(ac?.presentations || []), { leadId, date: presentation.date, notes }];

    // Update local state immediately - also set status to "Presented"
    set({
      leads: leads.map(l =>
        l.id === leadId
          ? { ...l, presentations: updatedLeadPresentations, status: 'Presented' }
          : l
      ),
      aircraft: aircraft.map(a =>
        a.id === aircraftId
          ? { ...a, presentations: updatedAircraftPresentations }
          : a
      )
    });

    // Sync to Supabase if authenticated
    if (isAuthenticated) {
      try {
        // Update lead presentations and status
        await supabase
          .from('leads')
          .update({
            presentations: updatedLeadPresentations,
            status: 'Presented'
          })
          .eq('id', leadId);

        console.log('âœˆï¸ Lead status updated to "Presented" after aircraft presentation');

        // Update aircraft presentations
        await supabase
          .from('aircraft')
          .update({ presentations: updatedAircraftPresentations })
          .eq('id', aircraftId);
      } catch (error) {
        console.error('Error syncing presentation to Supabase:', error);
      }
    } else {
      get().saveToLocalStorage();
    }

    createAutoTask('presentation', leadId, `Follow up on aircraft presentation to ${lead?.name}`);
  },

  // Notes Actions
  addNoteToLead: async (leadId, noteText) => {
    const { leads, isAuthenticated } = get();
    const lead = leads.find(l => l.id === leadId);
    if (!lead) return;

    const newNote = {
      id: Date.now(),
      text: noteText,
      timestamp: new Date().toISOString()
    };

    const updatedNotes = [...(lead.timestampedNotes || []), newNote];

    // Update local state immediately - also set status to "Interested"
    set({
      leads: leads.map(l =>
        l.id === leadId
          ? { ...l, timestampedNotes: updatedNotes, status: 'Interested' }
          : l
      )
    });

    // Sync to Supabase if authenticated
    if (isAuthenticated) {
      try {
        await supabase
          .from('leads')
          .update({
            timestamped_notes: updatedNotes,
            status: 'Interested'
          })
          .eq('id', leadId);

        console.log('ðŸ“ Lead status updated to "Interested" after adding note');
      } catch (error) {
        console.error('Error syncing note to Supabase:', error);
      }
    } else {
      get().saveToLocalStorage();
    }
  },

  addNoteToDeal: async (dealId, noteText) => {
    const { deals, isAuthenticated } = get();
    const deal = deals.find(d => d.id === dealId);
    if (!deal) return;

    const newNote = {
      id: Date.now(),
      text: noteText,
      timestamp: new Date().toISOString()
    };

    const updatedNotes = [...(deal.timestampedNotes || []), newNote];

    // Update local state immediately
    set({
      deals: deals.map(d =>
        d.id === dealId
          ? { ...d, timestampedNotes: updatedNotes }
          : d
      )
    });

    // Sync to Supabase if authenticated
    if (isAuthenticated) {
      try {
        await supabase
          .from('deals')
          .update({ timestamped_notes: updatedNotes })
          .eq('id', dealId);
      } catch (error) {
        console.error('Error syncing note to Supabase:', error);
      }
    } else {
      get().saveToLocalStorage();
    }
  },

  generateActionItemsFromDocument: async (dealId, documentType) => {
    const { deals, addTask } = get();
    const deal = deals.find(d => d.id === dealId);
    if (!deal || !deal.documentData) {
      throw new Error('Deal or document not found');
    }

    const today = new Date();
    const addDays = (days) => {
      const date = new Date(today);
      date.setDate(date.getDate() + days);
      return date.toISOString().split('T')[0];
    };

    // Extract text from document
    let extractedText = '';
    try {
      if (deal.documentType && deal.documentType.includes('pdf')) {
        // For PDF files, extract text using PDF.js
        const loadingTask = pdfjsLib.getDocument(deal.documentData);
        const pdf = await loadingTask.promise;

        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map(item => item.str).join(' ');
          extractedText += pageText + '\n';
        }
      } else {
        // For non-PDF, show instruction
        throw new Error('Please upload a PDF document for AI parsing');
      }
    } catch (error) {
      console.error('Document extraction error:', error);
      extractedText = 'DEMO_MODE'; // Fallback to demo mode
    }

    // Parse document with AI (or demo mode)
    const actionItems = await get().parseDocumentWithAI(extractedText, documentType, deal);

    console.log(`ðŸ“‹ Creating ${actionItems.length} tasks from action items...`);

    // Create tasks for each action item - use for...of to wait for each task
    let successCount = 0;
    for (const item of actionItems) {
      try {
        await addTask({
          title: `${deal.dealName}: ${item.title}`,
          description: item.description || `Extracted from ${documentType} document`,
          dueDate: item.dueDate || null,
          relatedTo: { type: 'deal', id: dealId },
          status: 'pending',
          priority: item.priority || 'medium',
          autoGenerated: true
        });
        successCount++;
      } catch (error) {
        console.error(`Failed to create task: ${item.title}`, error);
        // Continue with next task even if one fails
      }
    }

    console.log(`âœ… Successfully created ${successCount} out of ${actionItems.length} tasks`);

    // Update deal with timeline - only include items with valid dates
    const timeline = actionItems
      .filter(item => item.dueDate && item.dueDate.trim() !== '')
      .map(item => ({
        title: item.title,
        dueDate: item.dueDate,
        priority: item.priority || 'medium',
        completed: false,
        source: 'AI-extracted'
      }));

    const updatedDealData = {
      timeline: timeline,
      timelineGenerated: new Date().toISOString(),
      documentParsed: true
    };

    // Update local state
    set({
      deals: deals.map(d =>
        d.id === dealId
          ? { ...d, ...updatedDealData }
          : d
      )
    });

    // Sync to Supabase if authenticated
    const { isAuthenticated } = get();
    if (isAuthenticated) {
      try {
        await supabase
          .from('deals')
          .update({
            timeline: timeline,
            timeline_generated: updatedDealData.timelineGenerated,
            document_parsed: true
          })
          .eq('id', dealId);
      } catch (error) {
        console.error('Error syncing deal timeline to Supabase:', error);
      }
    } else {
      get().saveToLocalStorage();
    }

    return successCount;
  },

  parseDocumentWithAI: async (documentText, documentType, deal) => {
    // DEMO MODE: If no actual text or demo mode, use intelligent parsing
    if (documentText === 'DEMO_MODE' || !documentText || documentText.length < 100) {
      return get().intelligentDemoParser(documentType, deal);
    }

    // GEMINI AI MODE: Extract action items using Google Gemini
    const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY;

    if (GEMINI_API_KEY) {
      try {
        const prompt = `You are an expert in aircraft transactions. Parse this ${documentType} document and extract ALL action items with dates, priorities, and descriptions. 

Document Text:
${documentText}

Extract every action item, deadline, obligation, and requirement from this document. Only extract action items with solid deliverables. Return ONLY a valid JSON object with this exact format (no markdown, no code blocks):

{
  "actionItems": [
    {
      "title": "Brief action title",
      "description": "Detailed description with context from document",
      "dueDate": "YYYY-MM-DD",
      "priority": "high"
    }
  ]
}

Priority levels:
- high: Critical deadlines, payments, inspections
- medium: Important but flexible items
- low: Nice-to-have or informational items

Return ONLY the JSON object, no other text.`;

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            contents: [{
              parts: [{
                text: prompt
              }]
            }],
            generationConfig: {
              temperature: 0.2,
              topK: 40,
              topP: 0.95,
              maxOutputTokens: 8192,
            }
          })
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();

        // Extract text from Gemini response
        let textResponse = data.candidates?.[0]?.content?.parts?.[0]?.text;

        if (!textResponse) {
          throw new Error('No response from Gemini API');
        }

        // Clean up response - remove markdown code blocks if present
        textResponse = textResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

        // Parse JSON
        const parsed = JSON.parse(textResponse);

        if (parsed.actionItems && Array.isArray(parsed.actionItems)) {
          console.log(`âœ… Gemini extracted ${parsed.actionItems.length} action items from ${documentType}`);
          return parsed.actionItems;
        } else {
          throw new Error('Invalid response format from Gemini');
        }
      } catch (error) {
        console.error('Gemini AI parsing error:', error);
        console.log('Falling back to intelligent demo parser');
        // Fall through to demo parser
      }
    } else {
      console.log('No Gemini API key found. Add VITE_GEMINI_API_KEY to .env file');
    }

    // Fallback: Smart text parsing
    return get().intelligentDemoParser(documentType, deal, documentText);
  },

  intelligentDemoParser: (documentType, deal, documentText = '') => {
    const today = new Date();
    const addDays = (days) => {
      const date = new Date(today);
      date.setDate(date.getDate() + days);
      return date.toISOString().split('T')[0];
    };

    // Smart extraction from text if available
    const hasText = documentText && documentText.length > 100;
    let actionItems = [];

    if (documentType === 'LOI') {
      actionItems = [
        { title: 'Review and execute LOI', dueDate: addDays(2), priority: 'high', description: hasText ? 'Extracted from document section 1' : 'Initial LOI execution' },
        { title: 'Submit earnest money deposit', dueDate: addDays(3), priority: 'high', description: hasText ? 'Per deposit terms in document' : 'Initial deposit' },
        { title: 'Conduct initial aircraft inspection', dueDate: addDays(7), priority: 'high', description: 'Visual and documentation review' },
        { title: 'Review maintenance records', dueDate: addDays(7), priority: 'medium', description: 'Complete logbook review' },
        { title: 'Verify aircraft registration and title', dueDate: addDays(10), priority: 'medium', description: 'FAA registration check' },
        { title: 'Draft Purchase Agreement', dueDate: addDays(14), priority: 'high', description: 'Prepare full APA' },
        { title: 'Schedule pre-purchase inspection', dueDate: addDays(14), priority: 'high', description: 'Coordinate with inspection facility' }
      ];
    } else if (documentType === 'APA') {
      actionItems = [
        { title: 'Execute Aircraft Purchase Agreement', dueDate: addDays(1), priority: 'high', description: hasText ? 'Per document execution clause' : 'Sign APA' },
        { title: 'Submit balance of deposit', dueDate: addDays(2), priority: 'high', description: hasText ? 'Extracted from payment terms' : 'Additional deposit' },
        { title: 'Complete pre-purchase inspection', dueDate: addDays(7), priority: 'high', description: 'Full aircraft inspection' },
        { title: 'Review inspection report', dueDate: addDays(9), priority: 'high', description: 'Analyze findings and discrepancies' },
        { title: 'Negotiate any discrepancies', dueDate: addDays(12), priority: 'medium', description: 'Address inspection items' },
        { title: 'Finalize financing documents', dueDate: addDays(14), priority: 'high', description: 'Complete lender requirements' },
        { title: 'Obtain insurance certificate', dueDate: addDays(14), priority: 'high', description: 'Full hull and liability coverage' },
        { title: 'Complete FAA registration transfer', dueDate: addDays(20), priority: 'medium', description: 'File ownership documents' },
        { title: 'Schedule closing date', dueDate: addDays(21), priority: 'high', description: 'Coordinate all parties' },
        { title: 'Wire final payment', dueDate: addDays(28), priority: 'high', description: hasText ? 'Per closing instructions' : 'Transfer remaining funds' },
        { title: 'Physical aircraft delivery', dueDate: addDays(30), priority: 'high', description: 'Accept aircraft at location' },
        { title: 'Post-delivery inspection', dueDate: addDays(31), priority: 'medium', description: 'Verify condition and documentation' }
      ];
    }

    return actionItems;
  },

  addNoteToAircraft: async (aircraftId, noteText) => {
    const { aircraft, isAuthenticated } = get();
    const ac = aircraft.find(a => a.id === aircraftId);
    if (!ac) return;

    const newNote = {
      id: Date.now(),
      text: noteText,
      timestamp: new Date().toISOString()
    };

    const updatedNotes = [...(ac.timestampedNotes || []), newNote];

    // Update local state immediately
    set({
      aircraft: aircraft.map(a =>
        a.id === aircraftId
          ? { ...a, timestampedNotes: updatedNotes }
          : a
      )
    });

    // Sync to Supabase if authenticated
    if (isAuthenticated) {
      try {
        await supabase
          .from('aircraft')
          .update({ timestamped_notes: updatedNotes })
          .eq('id', aircraftId);
      } catch (error) {
        console.error('Error syncing note to Supabase:', error);
      }
    } else {
      get().saveToLocalStorage();
    }
  },

  // AI Spec Sheet Extraction
  extractAircraftDataFromPDF: async (pdfDataUrl) => {
    const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY;

    if (!GEMINI_API_KEY) {
      console.log('No Gemini API key found. Add VITE_GEMINI_API_KEY to .env file');
      return null;
    }

    try {
      console.log('ðŸ¤– Extracting aircraft data from spec sheet with AI...');

      // Extract base64 data from data URL
      const base64Data = pdfDataUrl.split(',')[1];

      const prompt = `You are an expert aircraft data analyst. Extract ALL aircraft specifications from this spec sheet PDF.

Extract and return ONLY a valid JSON object with this exact structure (no markdown, no code blocks):

{
  "manufacturer": "Aircraft manufacturer",
  "model": "Exact model designation",
  "yom": 2020,
  "serialNumber": "Serial number or MSN",
  "registration": "Registration number (N-number)",
  "totalTime": 1000,
  "category": "Piston|Turboprop|Light Jet|Midsize Jet|Super-Mid Jet|Heavy Jet|Ultra-Long Range|Airliner|Cargo",
  "location": "Current location",
  "price": 5000000,
  "summary": "A comprehensive 2-3 sentence summary highlighting key features, condition, and selling points of this aircraft.",
  "specifications": {
    "engines": "Engine details",
    "range": "Range in nautical miles",
    "speed": "Cruise speed",
    "passengers": "Passenger capacity",
    "baggage": "Baggage capacity"
  }
}

If any field cannot be determined from the document, use null. For price, use best estimate based on model and year. Make the summary compelling and professional.

Return ONLY the JSON object.`;

      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: [{
            parts: [
              { text: prompt },
              {
                inline_data: {
                  mime_type: "application/pdf",
                  data: base64Data
                }
              }
            ]
          }],
          generationConfig: {
            temperature: 0.2,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 8192,
          }
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      let textResponse = data.candidates?.[0]?.content?.parts?.[0]?.text;

      if (!textResponse) {
        throw new Error('No response from Gemini API');
      }

      // Clean up response
      textResponse = textResponse.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

      const extractedData = JSON.parse(textResponse);
      console.log('âœ… AI extracted aircraft data:', extractedData);

      return extractedData;
    } catch (error) {
      console.error('Error extracting aircraft data with AI:', error);
      return null;
    }
  },

  // Generate AI Summary for Aircraft
  generateAircraftSummary: async (aircraftData) => {
    const GEMINI_API_KEY = import.meta.env.VITE_GEMINI_API_KEY;

    if (!GEMINI_API_KEY) {
      return null;
    }

    try {
      const prompt = `You are an expert aircraft broker. Create a compelling, professional summary for this aircraft:

Manufacturer: ${aircraftData.manufacturer || 'Unknown'}
Model: ${aircraftData.model || 'Unknown'}
Year: ${aircraftData.yom || 'Unknown'}
Serial Number: ${aircraftData.serialNumber || 'Unknown'}
Total Time: ${aircraftData.totalTime || 'Unknown'} hours
Category: ${aircraftData.category || 'Unknown'}
Location: ${aircraftData.location || 'Unknown'}
Price: ${aircraftData.price ? `$${(aircraftData.price / 1000000).toFixed(1)}M` : 'Unknown'}

Create a 2-3 sentence professional summary that:
1. Highlights key features and specifications
2. Mentions condition and maintenance (if applicable)
3. Emphasizes value proposition and selling points
4. Uses compelling broker language

Return ONLY the summary text, no JSON, no markdown, no labels.`;

      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: prompt }]
          }],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 500,
          }
        })
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status}`);
      }

      const data = await response.json();
      const summary = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();

      console.log('âœ… AI generated summary:', summary);
      return summary;
    } catch (error) {
      console.error('Error generating AI summary:', error);
      return null;
    }
  }
}));